// handle the slider logic and the links drawer, displayed on small resolutions
// the offset calculated is always negative (because it is used as css left property, for the slider div)
define( 'ds2-uxn-content-bar',
    [
    'jquery',
    'ds2-uxn-content-bar-accessibility',
    'ds2-touch-detection',
    'ds2-content-navigation-tron-tracking'
    ], function($, Accessibility, touchDevice, DS2ContentNavigationTronTracking) {
        //Init Tron Tracking
        var TRON = new DS2ContentNavigationTronTracking.default();

        function UxnContentBar(component) {
        var CSS_CLASS_CONTENT_BAR_PLACEHOLDER = '.ds2-uxn-navigation-content-bar-placeholder',
            CSS_CLASS_CONTAINER = '.linksContainer',
            CSS_CLASS_LEFT = '.arrowLeft',
            CSS_CLASS_RIGHT = '.arrowRight',
            CSS_CLASS_SLIDER = '.slider',
            CSS_CLASS_SLIDER_ITEM = '.slider-item';
            CSS_CLASS_SLIDER_LINK = CSS_CLASS_SLIDER_ITEM + ' a';
            CSS_CLASS_ANCHOR = '.ds2-anchor';
            CSS_CLASS_SLIDER_ITEM_SELECTED = 'slider-item-selected';
            CSS_CLASS_CATEGORY_LINK_MOBILE = '.categoryLinkMobile';
            CSS_CLASS_CATEGORY_LINK = '.categoryLink a';
            CSS_CLASS_CATEGORY_LINK_TEXT = '.categoryLink .categoryText';
            CSS_CLASS_DRAWER_LAYER = '.drawerLayer';
            CSS_CLASS_DRAWER_LAYER_OPEN = 'drawer-layer--open';
            CSS_CLASS_DRAWER_LINKS = '.drawerLinks';
            CSS_CLASS_DRAWER_MOBILE_LINKS = '.mobileLinks';
            CSS_CLASS_DRAWER_MOBILE_ITEMS = '.item';
            CSS_CLASS_DRAWER_MOBILE_ITEM_SELECTED = 'item-selected';
            CSS_CLASS_DRAWER_MOBILE_ITEM_LINKS = '.item a';
            CSS_CLASS_DRAWER_MOBILE_SELECTED_ITEM_LINK = ' .item-selected a';
            CSS_CLASS_DRAWER_OPENER = '.drawerOpener';
            CSS_CLASS_DRAWER_OPENER_OPEN = '.drawerLinkOpen';
            CSS_CLASS_DRAWER_OPENER_CLOSE = '.drawerLinkClose';
            CSS_CLASS_DRAWER_LINK_HIDDEN = 'drawerLink--hidden';
            CSS_CLASS_DRAWER_LABEL = '.ds2-label';
            CSS_CLASS_PAGE_LINKS = '.pageLinks';
            CSS_CLASS_CTA = '.cta';
            ANCHOR_EXTRA_SCROLL_DESKTOP = 32;
            ANCHOR_EXTRA_SCROLL_MOBILE = 12;
            MOBILE_BREAK_POINT = 768;

        var contentBar = $(component),
            contentBarPlaceHolder = contentBar.parent().find(CSS_CLASS_CONTENT_BAR_PLACEHOLDER),
            container = $(contentBar).find(CSS_CLASS_CONTAINER),
            slider = $(contentBar).find(CSS_CLASS_SLIDER),
            sliderItems = $(slider).find(CSS_CLASS_SLIDER_ITEM),
            sliderLinks = $(slider).find(CSS_CLASS_SLIDER_LINK),
            arrowLeft = $(contentBar).find(CSS_CLASS_LEFT),
            arrowRight = $(contentBar).find(CSS_CLASS_RIGHT),
            categoryLinkMobile = $(contentBar).find(CSS_CLASS_CATEGORY_LINK_MOBILE),
            categoryLink = $(contentBar).find(CSS_CLASS_CATEGORY_LINK),
            categoryLinkText = $(contentBar).find(CSS_CLASS_CATEGORY_LINK_TEXT),
            drawerLayer = $(contentBar).find(CSS_CLASS_DRAWER_LAYER),
            drawerLinks = drawerLayer.find(CSS_CLASS_DRAWER_LINKS),
            drawerMobileLinks = drawerLinks.find(CSS_CLASS_DRAWER_MOBILE_LINKS),
            drawerMobileItems = drawerMobileLinks.find(CSS_CLASS_DRAWER_MOBILE_ITEMS),
            drawerMobileItemLinks = drawerMobileLinks.find(CSS_CLASS_DRAWER_MOBILE_ITEM_LINKS),
            drawerMobileSelectedItemLink = drawerMobileLinks.find(CSS_CLASS_DRAWER_MOBILE_SELECTED_ITEM_LINK),
            drawerLinkOpen = $(contentBar).find(CSS_CLASS_DRAWER_OPENER).find(CSS_CLASS_DRAWER_OPENER_OPEN),
            drawerLinkClose = $(contentBar).find(CSS_CLASS_DRAWER_OPENER).find(CSS_CLASS_DRAWER_OPENER_CLOSE),
            drawerLabel = $(contentBar).find(CSS_CLASS_DRAWER_OPENER).find(CSS_CLASS_DRAWER_LABEL),
            drawerDefaultLabelText = $(contentBar).find(CSS_CLASS_DRAWER_OPENER).find(CSS_CLASS_DRAWER_LABEL).first().text(),
            cta = $(contentBar).find(CSS_CLASS_CTA),
            pageLinks = $(contentBar).find(CSS_CLASS_PAGE_LINKS);

        var elements = {
            contentBar: contentBar[0],
            slider: slider[0],
            sliderItems: sliderItems.toArray(),
            sliderLinks: sliderLinks.toArray(),
            categoryLinkMobile: categoryLinkMobile[0],
            drawerLayer: drawerLayer[0],
            drawerLinks: drawerLinks[0],
            drawerMobileLinks: drawerMobileLinks[0],
            drawerMobileItems: drawerMobileItems.toArray(),
            drawerMobileItemLinks: drawerMobileItemLinks.toArray(),
            drawerMobileSelectedItemLink: drawerMobileSelectedItemLink[0],
            drawerLinkOpen: drawerLinkOpen[0],
            drawerLinkClose: drawerLinkClose[0],
        },
        selectors = {
            DRAWER_LAYER_OPEN: '.' + CSS_CLASS_DRAWER_LAYER_OPEN,
        },

        functions = {
            openDrawer: openDrawer,
            closeDrawer: closeDrawer,
            slideIfNeeded: slideIfNeeded,
            showHideRightArrowButton: showHideRightArrowButton,
        },
        events = {
            beforeDrawerOpen: 'beforeDrawerOpen',
            drawerOpen: 'drawerOpen',
            beforeDrawerClosed: 'beforeDrawerClosed',
            drawerClosed: 'drawerClosed',
        },
        accessibility = new Accessibility(elements, selectors, functions, events);
        accessibility.init();

        var containerWidth, sliderWidth, lastActiveItem;
        var sliderItemsWidths = [];
        var arrowLeftWidth;
        var arrowRightWidth;
        var rtlDirection;

        // cache the slider items
        var $sliderItemElements = slider.find(CSS_CLASS_SLIDER_ITEM);
        var $drawerItemElements = drawerMobileLinks.find(CSS_CLASS_DRAWER_MOBILE_ITEMS);
        // cache (in reversed order) the anchors which have a slider item pointing to them
        var $allAnchors = $(CSS_CLASS_ANCHOR);
        var $anchors = [];
        $allAnchors.each(function() {
            var id = $(this).attr('id').replace(/\./g,'\\.');
            if (slider.find('.slider-item > a[href="#' + id + '"]').length) {
                $anchors.push(this);
            }
        });

        // reverse the order to prevent cascade highlighting
        $anchors = $($anchors.reverse());

        // map each anchor id to their corresponding slider item
        var anchorIdToSliderItem = {};
        var anchorIdToDrawerItem = {}
        $anchors.each(function() {
            var id = $(this).attr('id').replace(/\./g,'\\.');
            anchorIdToSliderItem[id] = slider.find('.slider-item > a[href="#' + id + '"]').parent();
            anchorIdToDrawerItem[id] = drawerLayer.find('.item > a[href="#' + id + '"]').parent();
        });

        function init() {
            rtlDirection = $("html").attr("dir") == 'rtl';

            containerWidth =  container.outerWidth();
            sliderWidth = slider.outerWidth();
            arrowLeftWidth = parseInt(arrowLeft.css('font-size')) + 52;
            arrowRightWidth = arrowRight.outerWidth() + 52;

            initSliderItems();
            showHideRightArrowButton();

            arrowLeft.on('click', slideLeft);
            arrowRight.on('click', slideRight);
            drawerLinkOpen.on('click', openDrawer);
            drawerLinkClose.on('click', closeDrawer);
            drawerLayer.on('click', closeDrawer);

            // listen to resize
            $(window).on('resize', handleResize);

            // the content bar has fixed positioning once it reaches the top of the visible area
            handleFixedPositioning();
            $allAnchors.each(function() {
                contentBar.height();
                $(this).css("top", -(contentBar.height() + getExtraScroll()));
            });

            if ($anchors.length) {
                $(window).on('scroll', throttle(highlightNavigation, 300));
            }
            assignResizeObserver();

            if(touchDevice.any) {
                slider.addClass('touchDevice');
                sliderWidth = slider[0] ? slider[0].scrollWidth : 0;
                slider.scroll(function () {
                    handleArrows(1);
                });
            }

            handleCTASpacing();
            handleCategoryLinkWidthAndStyle();
        }

        function getExtraScroll() {
            if (isMobileLayout()) {
                return ANCHOR_EXTRA_SCROLL_MOBILE;
            } else {
                return ANCHOR_EXTRA_SCROLL_DESKTOP;
            }
        }

        function isMobileLayout() {
            // 768px is the magic values where the css media queries change from mobile to tablet
            return window.innerWidth < MOBILE_BREAK_POINT;
        }

        function resetSliderWidths(callback) {
            var i;
            sliderWidth = slider.outerWidth();
            if(touchDevice.any) {
                sliderWidth = slider[0] ? slider[0].scrollWidth : 0;
            }
            sliderItemsWidths = [];
            for (i = 0; i < $sliderItemElements.length; i++) {
                sliderItemsWidths.push($($sliderItemElements[i]).outerWidth());
            }
            callback();
        }

        function assignResizeObserver() {
            if (typeof ResizeObserver !== 'undefined') {
                var resizeObserver = new ResizeObserver(function () {
                    resetSliderWidths(function () {
                        handleResize();
                    })
                });
                if (elements.slider) {
                    resizeObserver.observe(elements.slider);
                }
            }
        }

        function showHideRightArrowButton() {
            if (sliderWidth <= containerWidth) {
                hideArrowRight();
            }
            else {
                showArrowRight();
            }
        }

        // throttle function, enforces a minimum time interval
        function throttle(fn, interval) {
            var lastCall, timeoutId;
            return function () {
                var now = new Date().getTime();
                if (lastCall && now < (lastCall + interval) ) {
                    // if we are inside the interval we wait
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(function () {
                        lastCall = now;
                        fn.call();
                    }, interval - (now - lastCall) );
                } else {
                    // otherwise, we directly call the function
                    lastCall = now;
                    fn.call();
                }
            };
        }

        function highlightNavigation() {
            // get the last active item
            lastActiveItem = $(`.${CSS_CLASS_SLIDER_ITEM_SELECTED}`);

            // get the current vertical position of the scroll bar
            var scrollPosition = $(window).scrollTop();

            $anchors.each(function(index) {
                var currentAnchor = $(this);
                // get the position of the anchor
                var anchorTop = Math.floor(currentAnchor.offset().top);

                // if the user has scrolled over the top of the anchor
                if (scrollPosition >= anchorTop) {
                    // get the anchor id
                    var id = currentAnchor.attr('id');
                    // get the corresponding slider item
                    var $sliderItem = anchorIdToSliderItem[id];
                    var $drawerItem = anchorIdToDrawerItem[id];
                    // if the link is not active
                    if (!$sliderItem.hasClass(CSS_CLASS_SLIDER_ITEM_SELECTED)) {
                        $sliderItemElements.removeClass(CSS_CLASS_SLIDER_ITEM_SELECTED);
                        $sliderItem.addClass(CSS_CLASS_SLIDER_ITEM_SELECTED);

                        slideIfNeeded($sliderItem);
                    }
                    if (!$drawerItem.hasClass(CSS_CLASS_DRAWER_MOBILE_ITEM_SELECTED)) {
                        $drawerItemElements.removeClass(CSS_CLASS_DRAWER_MOBILE_ITEM_SELECTED);
                        $drawerItem.addClass(CSS_CLASS_DRAWER_MOBILE_ITEM_SELECTED);
                        drawerLabel.text($drawerItem.text());
                    }
                    // break the each loop when anchor found
                    return false;
                } else {
                    $sliderItemElements.removeClass(CSS_CLASS_SLIDER_ITEM_SELECTED);
                    $drawerItemElements.removeClass(CSS_CLASS_DRAWER_MOBILE_ITEM_SELECTED);
                    drawerLabel.text(drawerDefaultLabelText);
                }
            });
            drawerMobileSelectedItemLink = drawerMobileLinks.find(CSS_CLASS_DRAWER_MOBILE_SELECTED_ITEM_LINK);
            elements.drawerMobileSelectedItemLink = drawerMobileSelectedItemLink[0];

            //TRON tracking anchorScroll
            var currentActiveItem = $(`.${CSS_CLASS_SLIDER_ITEM_SELECTED}`);

            if(lastActiveItem[0] !== currentActiveItem[0] && currentActiveItem[0]) {
                var selectedItem = currentActiveItem.children();

                TRON.anchorScroll(generateTronObject(selectedItem));

                lastActiveItem = currentActiveItem;
            }
        }

        function slideIfNeeded($sliderItem) {
            var itemIndex = $sliderItemElements.index($sliderItem);
            var previousItemIndex = getPreviousItemIndex();
            var nextItemIndex = getNextItemIndex();
            if (itemIndex >= nextItemIndex) {
                slideRight(itemIndex);
            } else if (itemIndex <= previousItemIndex) {
                slideLeft(itemIndex);
            }
        }

        function initSliderItems() {
            for (var i = 0; i < $sliderItemElements.length; i++) {
                sliderItemsWidths.push($($sliderItemElements[i]).outerWidth());
            }
            $sliderItemElements.on('click', function() {
                if (!$(this).hasClass(CSS_CLASS_SLIDER_ITEM_SELECTED)) {
                    $sliderItemElements.removeClass(CSS_CLASS_SLIDER_ITEM_SELECTED);
                    $(this).addClass(CSS_CLASS_SLIDER_ITEM_SELECTED);

                    //TRON tracking anchorClick
                    var selectedItem = $(this).children();

                    TRON.anchorClick(generateTronObject(selectedItem));
                }
            });
        }

        function generateTronObject(item) {
            return {
                anchorName: `${item.text()}`,
                hashName: `${item.attr('href')}`.replace(/^#/, ''),
            }
        }

        function handleFixedPositioning() {
            var contentBarOffsetTop = contentBar.offset().top;

            function checkScrollTop() {
                if ($(window).scrollTop() > contentBarOffsetTop) {
                    contentBar.addClass('ds2-uxn-navigation-content-bar_fixed');
                    // show the placeholder so that the below content doesn't jump when the content bar has fixed positioning
                    contentBarPlaceHolder.show();
                } else {
                    contentBar.removeClass('ds2-uxn-navigation-content-bar_fixed');
                    contentBarPlaceHolder.hide();
                }
            }
            checkScrollTop();
            $(window).on('scroll', function() {
                checkScrollTop();
            });
        }

        function handleArrows(newOffset) {
            var offset = newOffset <= 0 ? newOffset : getSliderOffset();
            if (offset + sliderWidth <= containerWidth + 1) {
                hideArrowRight();
            }
            else {
                showArrowRight();
            }
            if (offset >= -1) {
                hideArrowLeft();
            }
            else {
                showArrowLeft();
            }
        }

        function handleResize() {
            var newContainerWidth = container.outerWidth();
            if (sliderWidth <= newContainerWidth + 1) {
                // no need to slide
                hideArrowLeft();
                hideArrowRight();
                setSliderOffset(0);
            } else if (newContainerWidth > containerWidth) {
                // container size increased
                var offset = getSliderOffset();
                if (-offset + newContainerWidth > sliderWidth) {
                    // the slider is too far left after container increased
                    // avoid extra space remaining to the right
                    showArrowLeft();
                    hideArrowRight();
                    setSliderOffset(newContainerWidth - sliderWidth)
                }
            } else {
                // container size decrease, while the left offset is constant
                showArrowRight();
            }

            containerWidth = newContainerWidth;
            handleCategoryLinkWidthAndStyle();
        }

        function slideLeft(itemIndex) {
            var previousItemIndex = (typeof itemIndex === 'object') ? getPreviousItemIndex() : itemIndex;
            var offset = computePreviousOffset(previousItemIndex);
            setSliderOffset(offset);
            handleArrows(offset);
        }

        function getPreviousItemIndex() {
            var currentOffset = getSliderOffset();
            var index = sliderItemsWidths.length -1 ;
            var rightLimit = sliderWidth;
            while (Math.round(rightLimit - sliderItemsWidths[index] + currentOffset - arrowLeftWidth) >= 0 && index >= 0) {
                // loop until we find the leftmost visible link item
                rightLimit -= sliderItemsWidths[index];
                index--;
            }
            return index;
        }

        function computePreviousOffset(previousItemIndex) {
            var i;
            var itemsWidth = 0;
            var isThereCategoryText = $('.categoryText').width();
            var indexAddition = previousItemIndex > 0 && !(touchDevice.any && isThereCategoryText) ? 1 : 0;
            // compute the total width of the previous links
            for (i = 0; i < previousItemIndex - indexAddition; i++) {
                itemsWidth += sliderItemsWidths[i];
            }
            var newOffset = -itemsWidth;
            if (previousItemIndex - indexAddition > 0) {
                // if it is not the first item that we need to display, we also account for the arrow width
                newOffset += arrowLeftWidth;
            }
            return newOffset;
        }

        function slideRight(itemIndex) {
            var nextItemIndex = (typeof itemIndex === 'object') ? getNextItemIndex() : itemIndex;
            var offset = computeNextOffset(nextItemIndex);
            setSliderOffset(offset);
            handleArrows(offset);
        }

        function getNextItemIndex() {
            var currentOffset = getSliderOffset();
            var index = 0;
            while (Math.round(currentOffset + sliderItemsWidths[index] - containerWidth + arrowRightWidth) <= 1 && index < sliderItemsWidths.length) {
                // loop until we find the last visible item
                // please note that the initial offset is <= 0
                currentOffset += sliderItemsWidths[index];
                index++;
            }
            return index;
        }

        function computeNextOffset(nextItemIndex) {
            var i;
            var itemsWidth = 0;
            var isThereCategoryText = $('.categoryText').width();
            var indexAddition = nextItemIndex < sliderItemsWidths.length - 1 && !(touchDevice.any && isThereCategoryText) ? 1 : 0;
            // compute the width of the link items, to the left of the next visible item, and the next visible item
            for (i = 0; i <= nextItemIndex + indexAddition; i++) {
                itemsWidth += sliderItemsWidths[i];
            }
            var newOffset = containerWidth - itemsWidth;
            if (nextItemIndex + indexAddition < sliderItemsWidths.length - 1) {
                // if it is not the last item we need to account fo the right arrow width
                newOffset -= arrowRightWidth;
            }
            return newOffset;
        }

        function setSliderOffset(offset) {
            var offsetpx = offset + "px";
            if (touchDevice.any) {
                slider.animate({scrollLeft: -1 * offset});
            }
            else if (!rtlDirection) {
                slider.animate({left: offsetpx});
            } else {
                slider.animate({right: offsetpx});
            }
        }

        function getSliderOffset() {
            if (touchDevice.any) {
                return -1 * slider.scrollLeft();
            }
            if (!rtlDirection) {
                return parseFloat(slider.css('left'));
            } else {
                return parseFloat(slider.css('right'));
            }
        }

        function hideArrowLeft(skipAnimation) {
            arrowLeft.css('visibility', 'hidden');
            pageLinks.removeClass('arrow-left-active');
        }

        function showArrowLeft(skipAnimation) {
            arrowLeft.css('visibility', 'visible');
            pageLinks.addClass('arrow-left-active');
        }

        function hideArrowRight(skipAnimation) {
            arrowRight.css('visibility', 'hidden');
            pageLinks.removeClass('arrow-right-active');
        }

        function showArrowRight(skipAnimation) {
            arrowRight.css('visibility', 'visible');
            pageLinks.addClass('arrow-right-active');
        }

        function openDrawer() {
            $(component).trigger(events.beforeDrawerOpen);

            // make page not scrollable
            $('body').css('overflow', 'hidden');
            $('html, body').animate({
                scrollTop: contentBar.offset().top
                },
                500,
                function() {
                    drawerLinkOpen.addClass(CSS_CLASS_DRAWER_LINK_HIDDEN);
                    drawerLinkClose.removeClass(CSS_CLASS_DRAWER_LINK_HIDDEN);
                    drawerLayer.css('display', 'block');
                    drawerLinks.slideDown(250);
                    contentBar.addClass(CSS_CLASS_DRAWER_LAYER_OPEN);
                    $(component).trigger(events.drawerOpen);
                });
        }

        function closeDrawer() {
            $(component).trigger(events.beforeDrawerClosed);

            // make page scrollable
            $('body').css('overflow', 'auto');
            drawerLinks.slideUp(250, function() {
                drawerLinkOpen.removeClass(CSS_CLASS_DRAWER_LINK_HIDDEN);
                drawerLinkClose.addClass(CSS_CLASS_DRAWER_LINK_HIDDEN);
                drawerLayer.css('display', 'none');
                contentBar.removeClass(CSS_CLASS_DRAWER_LAYER_OPEN);
                $(component).trigger(events.drawerClosed);
            });
        }

        function handleCTASpacing() {
            if (!cta.children().length) {
                pageLinks.addClass('noCTA');
            }
        }

        function handleCategoryLinkWidthAndStyle () {
            /* If category link text is too long, it becomes two line text with ellipsis
            *  Before it's loaded we can't know what it's width should be (depends on the word break)
            *  But we have to know correct width in order to have correct "right margin" (not too much white space to the line spacer)
            *  So we have to put it into span so that we can check it's width, and then make the link itself have the same width
            *  We do it just for the screen width >=768px <1200px #BMWWEB-30574
            * */
            var windowWidth = window.innerWidth;
            var savedCategoryText = '';
            var categoryLinkTextWidth = 0;

            function changeCategoryLinkElement (element) {
                savedCategoryText = element.text();
                element.html('<span>' + savedCategoryText + '</span>');
                categoryLinkTextWidth = element.find('span').outerWidth();
                element.width(categoryLinkTextWidth + 1);
            }

            if (windowWidth >= 768 && windowWidth < 1200) {
                if (categoryLink.length) {
                    changeCategoryLinkElement(categoryLink);
                }
                if (categoryLinkText.length) {
                    changeCategoryLinkElement(categoryLinkText);
                }
            }
            else {
                categoryLink.width('');
                categoryLinkText.width('');
            }

        }

        if (slider.length) {
            init();
        }
        else {
            contentBar.css('display', 'none');
        }

    }

    return UxnContentBar;
});

define( 'ds2-uxn-content-bar-accessibility', ['jquery', 'ds2-accessibility'], function($, Accessibility) {
    function UxnContentBarAccessibility(elements, selectors, functions, events) {
        var component = elements.contentBar;
        var accessibility = new Accessibility(component);
        var keyboardSupportAdded = false;
        var screenReaderSupportAdded = false;
        var screenReaderTrap = {
            container: component,
            unreadables: [],
        };
        var ariaRoleOfMainRegion = "main";

        function init() {
            elements.drawerCloseButtonScreenReader = component.querySelector('.uxn-content-bar__close--screen-reader');
            elements.main = component.closest('main');

            addKeyboardSupport();
            addScreenReaderSupport();
        }

        function addKeyboardSupport() {
            if (!keyboardSupportAdded) {
                keyboardSupportAdded = true;

                addKeyboardSupportForSlider();
                addKeyboardSupportForLayer();
            }
        }

        function addKeyboardSupportForSlider() {
            slideLinksWhenFocused();

            addSupportForArrowKeys({
                container: elements.slider,
                links: elements.sliderLinks
            });
        }

        /**
         * Enables keyboard navigation through a list of links via arrow keys in the specified container.
         * LEFT and UP arrow keys: focus previous link.
         * RIGHT and DOWN arrow keys: focus next link.
         *
         * @param params Configuration object with the following parameters:
         *               {HTMLElement} container
         *               {Array} links
         */
        function addSupportForArrowKeys(params) {
            var container = params.container,
            links = params.links || [];
            if (!container || links.length === 0) return;

            accessibility.addKeyListener('down', {
                element: container,
                keyCodes: [accessibility.keyCodes.ARROW_DOWN, accessibility.keyCodes.ARROW_RIGHT],
                cancel: true,
                fn: function () {
                    focusSiblingLink({
                        links: links,
                    });
                },
            });
            accessibility.addKeyListener('down', {
                element: container,
                keyCodes: [accessibility.keyCodes.ARROW_UP, accessibility.keyCodes.ARROW_LEFT],
                cancel: true,
                fn: function () {
                    focusSiblingLink({
                        links: links,
                        direction: -1
                    });
                },
            });
        }

        /**
         * Focuses a link next to the currently focused link, depending on the chosen direction.
         *
         * @param params Configuration object with the following parameters:
         *               {Array} links
         *               {number} direction
         *                        Default: 1
         *                        Direction for next link: 1
         *                        Direction for previous link: -1
         */
        function focusSiblingLink(params) {
            var links = params.links || [];
            var focusedElement = document.activeElement;
            var focusedLinkIndex = links.indexOf(focusedElement);
            if (focusedLinkIndex === -1) return;

            var direction = params.direction === 1 || params.direction === -1 ? params.direction : 1,
            lastLinkIndex = links.length - 1,
            siblingLinkIndex = focusedLinkIndex + direction;
            if (siblingLinkIndex < 0 || siblingLinkIndex > lastLinkIndex) return;

            var siblingLink = links[siblingLinkIndex];
            accessibility.focusElement(siblingLink);
        }

        function slideLinksWhenFocused() {
            elements.sliderItems.forEach(function (sliderItem) {
                var sliderLink = sliderItem.querySelector('a');

                sliderLink.addEventListener('focus', function () {
                    functions.slideIfNeeded($(sliderItem));
                });
            });
        }

        function addKeyboardSupportForLayer() {
            focusSelectedLinkAfterOpeningLayer();
            addKeyboardTrapForLayer();

            addSupportForArrowKeys({
                container: elements.drawerMobileLinks,
                links: elements.drawerMobileItemLinks
            });

            closeDropdownLayerOnEscape();
            focusDropdownHeaderAfterClosingLayer();
        }

        function focusSelectedLinkAfterOpeningLayer() {
            $(component).on(events.drawerOpen, function () {
                if(elements.drawerMobileSelectedItemLink) {
                    accessibility.focusElement(elements.drawerMobileSelectedItemLink);
                }
            });
        }

        function addKeyboardTrapForLayer() {
            $(component).on(events.drawerOpen, function () {
                accessibility.activateKeyboardTrap({
                    container: component,
                    includeContainer: false,
                    requiredAncestor: selectors.DRAWER_LAYER_OPEN,
                });
            });
        }

        function closeDropdownLayerOnEscape() {
            accessibility.addKeyListener('up', {
                element: component,
                keyCodes: [accessibility.keyCodes.ESC],
                fn: function () {
                    functions.closeDrawer();
                },
            });
        }

        function focusDropdownHeaderAfterClosingLayer() {
            $(component).on(events.drawerClosed, function () {
                setTimeout(function () {
                    accessibility.focusElement(elements.drawerLinkOpen);
                }, 0);
            });
        }

        function addScreenReaderSupport() {
            if (!screenReaderSupportAdded) {
                screenReaderSupportAdded = true;

                addScreenReaderTrapForLayer();
                closeLayerAfterClickOnCloseButtonForScreenReaders();
            }
        }

        function addScreenReaderTrapForLayer() {
            activateScreenReaderTrapBeforeOpeningLayer();
            deactivateScreenReaderTrapBeforeClosingLayer();
        }

        function activateScreenReaderTrapBeforeOpeningLayer() {
            $(component).on(events.beforeDrawerOpen, function () {
                // make "close" button readable for screen readers
                accessibility.makeElementReadable(elements.drawerCloseButtonScreenReader);

                // set the role of the "main" region to "none"
                if (elements.main) {
                    ariaRoleOfMainRegion = elements.main.getAttribute('role');
                    accessibility.setAriaRole(elements.main, 'none');
                }

                setTimeout(function () {
                    screenReaderTrap = accessibility.activateScreenReaderTrap(component);
                }, 500);
            });
        }

        function deactivateScreenReaderTrapBeforeClosingLayer() {
            $(component).on(events.beforeDrawerClosed, function () {
                // make "close" button unreadable for screen readers
                accessibility.makeElementUnreadable(elements.drawerCloseButtonScreenReader);

                // restore the previous role of the "main" region
                if (elements.main) {
                    accessibility.setAriaRole(elements.main, ariaRoleOfMainRegion);
                }

                setTimeout(function () {
                    accessibility.deactivateScreenReaderTrap(screenReaderTrap);
                }, 500);
            });
        }

        function closeLayerAfterClickOnCloseButtonForScreenReaders() {
            elements.drawerCloseButtonScreenReader.addEventListener('click', function () {
                functions.closeDrawer();
            });
        }

        return {
            init: init,
        }
    }

    return UxnContentBarAccessibility;
});

